<?php
/**
 *  SeekQuarry/Yioop --
 *  Open Source Pure PHP Search Engine, Crawler, and Indexer
 *
 *  Copyright (C) 2009 - 2014  Chris Pollett chris@pollett.org
 *
 *  LICENSE:
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  END LICENSE
 *
 * @author Shailesh Padave shaileshpadave49@gmail.com
 * @package seek_quarry
 * @subpackage library
 * @license http://www.gnu.org/licenses/ GPL3
 * @link http://www.seekquarry.com/
 * @copyright 2009 - 2014
 * @filesource
 */
/**
 * This class is used to rank the matching document from the generated summary
 * during crawl using wordnet raking function.
 * @package seek_quarry
 * @subpackage library
 */
class WordNetScoreCalculator
{
    /**
     * Gets array of WordNet score for given input array of summaries
     * @param array $summary an array of summaries which is generated
     *      during crawl time.
     * @param array $similar_words an array of synonyms which is generated by
     *      WordNet.
     *@returns array of Wordnet score for each document
     */
    static function getScore($summary, $similar_words)
    {
        $score = array();
        //if there are no similar words then
        if(empty($similar_words)) {
            return;
        } else {
            for($i = 0; $i < count($similar_words); $i++) {
                $query = $similar_words[$i];
                $terms = explode(' ', $query);
                $summary = self::changeCaseOfArray($summary);
                $query = mb_strtolower($query);
                $idf = self::calculateIDF($summary, $query, $terms);
                $tf = self::calculateTF($summary, $query, $terms);
                $summary_count = count($summary);
                $count_terms = count($terms);
                $bm25_result[$i] =
                    self::calculateBM25($idf, $tf, $count_terms,
                    $summary_count);
            }
            if ( count($bm25_result) == 1){
                for($i = 0; $i < $summary_count; $i++) {
                    $temp = 0;
                    $temp = $bm25_result[0][$i];
                    $score[$i] = $temp;
                }
            } else {
                for($i = 0; $i < $summary_count; $i++) {
                    $temp = 0;
                    $temp = $bm25_result[0][$i] * (2/3) +
                            $bm25_result[1][$i] * (1/3);
                    $score[$i] = $temp;
                }
            }
            return $score;
            }
        }
    /**
     * To make lower case for all the input variables
     * @param array $summary an array of summaries
     * @returns array of with strings converted to
     * lower case
     */
    static function changeCaseOfArray($summary)
    {
        for($i = 0; $i < count($summary); $i++) {
            $summary[$i] = mb_strtolower($summary[$i], 'UTF-8');
        }
        return $summary;
    }
    /**
     * To get the total number of characters in input array
     * @param array $summary an array of summaries
     * @returns number of characters in input array
     */
    static function getlength($summary)
    {
        $summary_count = count($summary);
        $str_len =0;
        for($i = 0; $i < $summary_count; $i++) {
            $str = $summary[$i];
            $str_len = $str_len + strlen($str);
        }
        return $str_len;
    }
    /**
     * To get the term frequency in given summary array
     * @param array $summary an array of summaries
     * @param array $query an array of words generated by wordnet output
     * @returns array of term frequency for each query term
     */
    static function calculateTF($summary, $query, $terms)
    {
        $k1=1.5;
        $b=0.75;
        $tf_values = array();
        $tfbm25 = array();
        $doc_length = self::getlength($summary);
        if(count($summary) != 0) {
            $avg_length = $doc_length / count($summary);
        } else {
            $avg_length = 0;
          }
        $tf_values = self::calculateWordFreq($summary, $terms);
        for($i = 0; $i < count($terms); $i++) {
            for($j = 0; $j <count($summary); $j++) {
                $frequency = $tf_values[$i][$j];
                $tfbm25[$i][$j] =
                ($frequency*($k1+1))/($frequency+$k1*((1-$b)+
                    $b*($doc_length/$avg_length)));
            }
        }
        return $tfbm25;
    }
    static function calculateWordFreq($summary, $query_array)
    {
        $tf_values = array();
        for($i = 0; $i < count($query_array); $i++) {
            for($j = 0; $j < count($summary); $j++) {
                  $frequency = substr_count($summary[$j], $query_array[$i]);
                  $tf_values[$i][$j] = $frequency;
            }
        }
        return $tf_values;
    }
    /**
     * To get the BM25 Score in given summary array
     * @param array $idf inverse Doc frequency for given query array
     * @param array $tf term frequency for given query array
     * @param $count_terms count for number of queries
     * @param $summary_count count for input summaries
     * @returns array of BM25 score for each document
     */
    static function calculateBM25($idf, $tf, $count_terms, $summary_count)
    {
        $score = array();
        for($i = 0; $i < $count_terms; $i++) {
            for($j = 0; $j < $summary_count; $j++) {
                $bm25_score[$i][$j] = $idf[$i] * $tf[$i][$j];
            }
        }
        for($i = 0; $i < $summary_count; $i++) {
            $val = 0;
            for($j = 0; $j< $count_terms; $j++) {
                $val += $bm25_score[$j][$i];
            }
            $score[$i] = $val;
        }
        return $score;
    }
    /**
     * To get the Inverse Doc frequency in given summary array
     * @param array $summary an array of summaries
     * @param array $query an array of words generated by wordnet output
     * @returns array of Inverse Doc frequency for each query term
     */
    static function calculateIDF($summary, $query, $terms)
    {
        $N = count($summary);
        $Nt = array();
        $term_count = 0;
        for($i = 0; $i < count($terms); $i++) {
            $cnt_Nt = 0;
            $term_count++;
            foreach($summary as $value)
            {
                $pattern = "/".$terms[$i]."/";
                if(preg_match($pattern, $value)) {
                    $cnt_Nt++;
                }
            }
            $Nt[$i]=$cnt_Nt;
            if($Nt[$i] != 0) {
                $idf[$i] = log10($N / $Nt[$i]);
            } else {
                $idf[$i] = 0;
            }
        }
        return $idf;
    }
}
?>